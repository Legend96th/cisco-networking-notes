  # OSPF
  Open Shortest Path First
  
  * Open standard
  * Link-State
  * Symbol: "O"
  * AD = 110
  * VLSM
  * Multicast 
    * 224.0.0.5 || FF02::5 : All OSPF routers
    * 224.0.0.6 || FF02::6 : All designated routers
  * Runs the Dijkstra Shortest Path First (SPF) algorithm to determine the shortest path to a network using link bandwidth as cost
  * Metric (cost) = bandwidth:
    * Metric = (Reference bandwidth) / (Interface bandwidth) 
    * Default reference bandwidth = 10^8 (100Mbps)
    * E2 = 20 static (redistributed)
    * E1 = 20 + cost (redistributed)
  * Summirization
    * Only works if all the subnets are consecutif 
    * eg: if we have a router attached to these networks: 10.0.0.0, 10.0.1.0, 10.0.2.0, 10.0.3.0, starting from the left, count the number of bits that are the same accross all the networks, that number is considered as a CIDR number, convert it to wildcard mask & use it only once with OSPF
  * Neighbor relationships with Hello packets
  * Hierarchal structure with areas
  * Sends Link State advertisements (LSAs) to other routers in an area
  * Constructs a link state database (LSDB) from received LSAs
  * If the routes costs are the same use load balancing
  * Authentication:
    * No authentication
    * Clear text
    * MD5
    * SHA1 & SHA2
    * IPSEC
  
  Notes
  * Uses the loopback to see if the local OSPF is running correctly
  
  ---
  # Router ID - RID
  
  * OSPF elects a RID when the process comes up 
  * Elected based on:
    * `router-id` command under the OSPF instance
    * Highest IP address of a not administratively disabled loopback interface
    * Highest IP address of a not administratively disabled physical interface
  
  
  
  ---
  # Timers:
  
  * Hello time: 10s
  * Hold down time: 40s (4 tries)
  * Dead interval: 40 seconds
  
  
  * Dead timer: The time (in seconds) that an OSPF-enabled interface will wait to receive a Hello message from an adjacency, before considering that adjacency to be down
    * Dead timer = Hello timer * 4
  
  ---
  # OSPF packets
  
  * Hello: 
    * Dynamically discover neighbors
    * Maintain neighbor relationships (adjacencies)
    * Contains:
      * Hello and dead interval
      * Authentication
      * Area ID
      * Router-ID
      * Prefix length
      * Stub-area flag
      * Neighbors
      * DR / BDR
  * DD (Database description): List of LSAs known to a router
  * LSR (Link State request)
  * LSU (Link State update)
    * LSA (Link State Advertisment )  
      * **Not a packet type** just a piece of information
      * One or more LSA can be in an LSU
      * When an LSA is generated locally or received from an adjacency, its flooded to all other adjancies
      * Age out after 1 hour
      * Refreshed every 30 min
      * Different types carry different data
      * Contains informations about a locally conncted link:
        * Network
        * Type of link (Ethernet, PPP...etc)
        * Neighbors
        * ...
  * LSAck (Link State Acknowledgment)
  
  ---
  # LSA types
  
  * **Type-1: router LSA**
    * Build SPF tree
    * Flooded within an area
    * Informs an area about networks inside of it
  * Type-2
    * Informs routers about DR
    * Generated by the DR
    * Circulates on the same link (isn't sent to other links)
  * **Type-3: Summary LSA**
    * Sent by ABR
    * Sent from one area to another
    * Informs an area about networks in another area
  * Type-4
    * Generated by ASBR
    * Informs routers about ASBR
    * Sent to all OSPF routers (same or different area)
  * **Type-5**
    * Sent by the ASBR 
    * Sent to all OSPF routers (same or different area)
    * Informs an area about networks learnt external from OSPF
  * Type-7
    * Sent by the ASBR in NSSA area
    * Sends external routes to all OSPF routers
  * Type-  
    * Describe networks and subnets
  
  ---
  # SPF tree
  
  * Constructed using the received LSAs
  * Uses a lot of CPU
  * When a new LSA is received, **a new tree is calculated** (from 0)
  
  ---
  # Parameters that should match between OSPF neighbors (adjancies)
  
  * OSPF enabled
  * Declare network
  * Passive interface
  * **Area ID**
  * Presence of a router ID (different between the neighbors)
  * **Hello interval**
  * **Dead interval**
  * Subnet 
  * **Subnet mask** (in MultiAccess networks)
  * Autherntication type
  * Autherntication credentials
  * DR compatibility
    * Either use or don't use DR
  * DR presence (in MultiAccess networks)
  * **MTU size** [[!]]
    * Generates an inconsitant OSPF database
    * Mismatching MTU will lead to routers stuck in the EXSTART state
    * Either same or use `ip mtu ignore` (*not recomended*)
  * ACL [[!]]
  * May need to manually specify neighbor address (depending on network type)
  * Reference bandwidth
  * Stub area configuration (if any)
  * Discontiguity of an area
    * An area that finds that the same area is on 2 sides
  * Backbone area
  
  
  
  
  ---
  
  # Neighbors:
  * Reside on the same network link
  * Exchange Hello messages (224.0.0.5 || FF02::5)
  
  # Adjacencies:
  * Are neighbors
  * Have exchanged Database Description (DD) packets and Link State Updates (LSUs)
  * Forming an Adjacency:
    * One way communication (sender or receiver at a given time)
      * Both (or one) routers are in the down state if there is no connectivity between
      * Both links are up 
        * R1 sends a Hello message to R2 (State of R2 in R1 = "init state")
        * When R2 receives it, it notices that it's router ID is not listed in it's neighbors list (State of R1 in R2 = "init state")
        * R2 adds R1 in it's neighbors table and then sends back a Hello message to R1 
      * R1 receives a Hello message from R2 containing R1's router ID (R1 now knows that R2 has it in it's neighbors table). 
        * R1 adds R2 to it's neighbors table then, R1 switches to a **2-Way state**. 
        * After that, it sends a Hello message back to R2
      * R2 receives a Hello message from R1 containing R2's router ID (R2 now confirms that R1 has it in it's neighbors table). 
        * R2 now is in a **2-Way state**.
    * Two way communication (both send & receive at the same time)
      * State = **2-Way**. DR/BDR election is done (if needed)
      * State = **ExStart**. Primary / Secondary routers are selected
        * Primary: Sends the DD packet to the secondary router
        * Secondary: Sends an Ack to the primary router
      * State = **Exchange**. DD packets are exchanged between the routers
      * State = **Loading**. 
        * Routers query one another (using LSRs) for missing entries 
        * Answers to these LSRs are sent withing LSUs
      * State = **Full**. Adjacency fully formed. Hello packets exchanged to maintain neighborship
  
  ---
  
  # OSPF neighbor state
  
  * Down: No active neighbor detected
  * Init: Hello packet received
  * 2-WAY: Own router ID in received hello
  * ExStart: Master and slave roles determined
  * Exchange: Database description packets sent
  * Loading: Exchange of LSRs and LSUs
  * Full: Neighbors fully adjacent
  
  ---
  # Areas 
  
  * Multiple areas
  * We always have Area 0 which is called the backbone
  * ((Each area holds a maximum of 50 router)) 
  * All the routers in the same area should have the same LSDB
  * Areas must be connected to area 0 to connect to all the other areas, otherwise that area will only connected to the directly connected areas
    * **Virtual-Link** can be used to connect to all areas without connecting to the area 0
  
  ---
  # OSPF router types
  * **ABR** (Area Border Roter): 
    * A router with at least one interface in the backbone area and at least one interface in a non-backbone area
    * A router that connects 2 or more areas is called ABR (Area Boundry Router)
    * An ABR has to apply the SPF algorithm for all the areas that it's linked to while an AR has to apply it for it's own area only 
  * **ASBR** (Autonomous System Boundry Router): A router that connects to another routing protocol
  * Internal router: A router with all links in the same area
  * Backbone router: A router that has at least one link in area 0
  
  
  
  ---
  
  # OSPF network types
  
  * OSPF classifies networks based on L2 encapsulation type
  * Why:
    * DR/BDR
    * Multiaccess
    * Timers
    * /// ra7et :) 
  * Network types:
    1. Dynamically determined by OSPF
        * Point to Point
          * PPP, HDLC, Frame-Relay
          * Two routers directly connected
          * No DR and BDR
          * Picks up neighbors dynamically
          * Timers:
            * Hello interval: 10 seconds
            * Dead interval: 40 seconds
        * BMA (Broadcast Multi Access)
          * Ethernet, Token Ring, FDDI
          * Router are inter-connected with a switch  
          * A DR & BDR are elected
          * Dynamic neighbors
          * No need for a full mesh of adjacencies
          * Timers:
            * Hello interval: 10 seconds
            * Dead interval: 40 seconds
        * Poing to multipoint
          * Frame-relay
          * A numbered P2P interface having 1 or more neighbors
          * A group of routers where 1 connects to them all  (like a tree with one root & others connecting to it) (B,C,D....etc all connected directly to A)
          * No DR and BDR
          * Dynamic neighbors
          * Timers:
            * Hello interval: 30 seconds
            * Dead interval: 120 seconds
        * Loopback
    2. Statically determined by user
        * NBMA (Non-Broadcast Multi Access)
          * Frame-Relay
          * Elects a DR and a BDR
            * Since the topology is a non broadcast, they have to be set manually (in a way that they are connected to every other router) by change the priority of those that won't be elected to 0 & setting the priority of the DR higher than that of the BDR
          * Static neighbors 
          * Timers:
            * Hello interval: 30 seconds
            * Dead interval: 120 seconds
        * Point to multipoint nonbroadcast
          * Frame-relay
          * A numbered P2P interface having 1 or more neighbors
          * A group of routers where 1 connects to them all  (like a tree with one root & others connecting to it) (B,C,D....etc all connected directly to A)
          * Doesn't elect a DR and BDR
          * Static neighbors 
          * Timers:
            * Hello interval: 30 seconds
            * Dead interval: 120 seconds
        
      
  
  **Note**
  * **If network type is not matching up on 2 interfaces, we can form an adjacency yet we will NOT be exchanging route information**
  * Broadcast is the defualt network type on Ethernet networks
  * Point-to-Point is the default network type on Frame Relay point-to-point **subinterfaces**
  * Non-Broadcast (NBMA) is the default network type on Frame Relay **physical interfaces and multipoint subinterfaces**
  * Network type can be manally set on some interfaces
  
  ---
  
  # Designated & Backup Designated Routers
  
  * Elected only in **BMA & NBMA** topologies
  * In each group of router connected with a switch, a master router (called "Designated Router" - DR) & a backup master router (called "Backup DR" - BDR) are elected
    * The DR is responsible for sending an update to the neighbors that are received from other neighbors
    * The BDR acts as a backup to the DR in case it goes off
    * The DROTHERS are all the other routers
  * Number of adjacencies in a full mesh topology = (n * (n-1)) / 2 [n: number of routers]
  * If a DR (or BDR) is already elected, if we add a higher priority router, it will **NOT** take it's place
  * By default, the first router that comes online is elected as a DR. Only if 2 or more routers come up at the same time is when we need to elect
  * The hello protocol is used to elect a DR:
    * A DR & BDR are selected based on: 
      * The highest priority that values from 0 to 255 
      * The default priority is  1
      * If the priority is set to 0 the router will not become the DR
    * If the priorities are all the same, the highest RID (router ID) is elected as DR.
    * If a RID is not configured, the highest IP address of a loopback interface (that is currently up) becomes the RID
    * If a router has no loopback interfaces, the highest IP address of a non-loopback interface (that is currently up) becomes the RID
  * First we elect a DR then a BDR
  * When a new network is connected, a message to the DR & BDR is sent via 224.0.0.6 (others dont listen to this multicast). After that, the other routers are informed by the DR via 224.0.0.5.
  * The DR is responsible of receiving informations about new networks & sending them back to the other routers
  * The BDR is a backup to be used if the DR is down.
  
  ---
  # OSPF tables
  
  * Neighbor table
  * Link-State database
  * SPF tree
  * Routing table
  
  ---
  # Cost
  
  * Based on interface bandwidth
  * Best path to a network is the path with the lowest cost 
  * Can be configured explixitly or affected by changing the interface bandwidth
  
  The default cost of passing by a link (without changing the reference bandwidth)
  
  | Speed   | Cost |
  | ------- | ---- |
  |128 Kbps |	781|
  |384 Kbps |	266|
  |768 Kbps |	133|
  |1.544 Mbps |	64|
  |10 Mbps |	10|
  |100 Mbps |	1|
  |1 Gbps |	1|
  |10 Gbps |	1|
  |40 Gbps |	1|
  |100 Gbps |	1|
  
  
  ---
  # OSPFv3
  OSPF for IPv6 networks
  
  * Similarities with OSPFv2:
    * Same message types
    * Same SPF algorithm, LSDB and metric
    * Requires a Router-ID (32-bit)
    * Same process for neighbor discovery and establishment
  * Differences with OSPFv2
    * Neighbors formed with Link-Local addresses
      * No need for global addressing on those links
    * Neighbors don't need same global prefixes on the same link
    * Changes to name/functionality of some LSAs
  
'''
